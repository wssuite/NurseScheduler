/*
 * Copyright (C) 2020 Antoine Legrain, Jeremy Omer, and contributors.
 * All Rights Reserved.
 *
 * You may use, distribute and modify this code under the terms of the MIT
 * license.
 *
 * Please see the LICENSE file or visit https://opensource.org/licenses/MIT for
 * full license detail.
 */

#include "tools/DemandGenerator.h"
#include "tools/Tools.h"
#include "data/Nurse.h"

using std::string;
using std::vector;
using std::map;
using std::pair;

//----------------------------------------------------------------------------
// Constructors and destructors
//----------------------------------------------------------------------------

DemandGenerator::~DemandGenerator() {}


//----------------------------------------------------------------------------
// Check the feasibility of a demand scenario
//----------------------------------------------------------------------------

bool DemandGenerator::checkDemandFeasibility(PDemand pDemand) {
  // Todo: build empty preferences and empty initial state to test feasibility
  // Create empty preferences and initial states
  // (this represents the most favorable situation)
  // They are needed to run the greedy algorithm.
  // We prefer take empty objects than arbitrary values,
  // because the optimization of the current week is likely
  // to find a favorable situation
//  PPreferences pPref = new Preferences(pScenario_->nbNurses_,
//                                       pScenario_->nbDays(),
//                                       pScenario_->nbShifts_);
//  vector<State> emptyStates;
//  for (int i = 0; i < pScenario_->nbNurses_; i++) {
//    State state;
//    emptyStates.push_back(state);
//  }
//
//  Tools::throwError("checkDemandFeasibility is not implemented.");

  return true;
}

//----------------------------------------------------------------------------
// Generate nbDemands_ demand scenarios through perturbations of the demand
// history
// Each demand must consider nbDays_ days
//----------------------------------------------------------------------------

vector2D<PDemand> DemandGenerator::generatePerturbedDemands() {
  // number of demands generated until now
  vector2D<PDemand> generatedDemands;

  // Generate the demands
  for (int c = 0; c < nbDemandsToGenerate_; c++)
    generatedDemands.push_back(generateSinglePerturbatedDemands());

  return generatedDemands;
}

// generate 1 demand through perturbations of the demand history
vector<PDemand> DemandGenerator::generateSinglePerturbatedDemands(
    bool checkFeasibility) {

  vector<PDemand> newDemands;

  // number of demands in the history
  int nbPastDemands = demandHistory_.size();

  // the generation of demands will depend on the number of weeks
  // treated by the demand
  int nbWeeksInGeneratedDemands = (nbDaysInGeneratedDemands_ - 1) / 7 + 1;

  // the demands are going to be generated by perturbing past demands
  // one reference history demand is randomly drawn for each week
  vector<int> indexInHistory(nbWeeksInGeneratedDemands);
  for (int i = 0; i < nbWeeksInGeneratedDemands; i++)
    indexInHistory[i] = rdm_() % nbPastDemands;

  int j = 0;
  while (j < demandHistory_.front().size()) {
    // create the first week
    PDemand pCompleteDemand =
            demandHistory_[indexInHistory[0]][j]->randomPerturbation();

    // create the following weeks append them to the complete demand
    for (int i = 1; i < nbWeeksInGeneratedDemands; i++)
      pCompleteDemand->pushBack(
              demandHistory_[indexInHistory[i]][j]->randomPerturbation());

    // keep only the required number of days
    pCompleteDemand->keepFirstNDays(nbDaysInGeneratedDemands_);

    // keep the generated demand only if it is feasible
    if (checkFeasibility && !checkDemandFeasibility(pCompleteDemand))
      continue;

    newDemands.push_back(pCompleteDemand);
    j++;
  }

  // keep the generated demand only if it is feasible
  return newDemands;
}





